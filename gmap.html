<!DOCTYPE html>
<html>
	<head>
		<title>Gmap for Autolab</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<meta charset="utf-8">
		<style>
			html, body, #map_canvas
			{
				margin: 0;
				padding: 0;
				height: 90%;
				width: 100%;
			}
		</style>
		<script src="https://maps.googleapis.com/maps/api/js?v=3.exp&sensor=false"></script>
		<script>
// by fzhan@Autolab
// trajectories and grid plots for robots on a google map

var TIME_OUT = 1000, LAB = [49.276802, -122.914913], GRID_SIZE = .001, GRID_NUM = 20, TRAJ_NUM = 20, ROBOT_NUM = 10;
var map, last_coord = new Array(), coord = new Array();
var rpath = new Array(), grid = {}, view_type = "basic", redis_ret = {}, robot = new Array(), grid_value = {}, follow = "none";
// clear grid data from the map
function clear_grid()
{
	for (key in grid)
	{
		grid[key].setMap(null);
	}
}
// transform the coordinate into grid position
function coord_to_grid(x, y)
{
	return [Math.round((x - LAB[0] - GRID_SIZE/2) / GRID_SIZE), Math.round((y - LAB[1] - GRID_SIZE/2) / GRID_SIZE)];
}
// let the map follow a robot
function follow_robot(form)
{
	follow = form.follow.value;
}
// change view
function change_view(form)
{
	if (form.view.value == view_type)
		return;
	clear_grid();
	view_type = form.view.value;
}
// pop up a info window on a grid
function info_wnd(event)
{
	var grid_pos = coord_to_grid(event.latLng.lat(), event.latLng.lng());
	var info;
	if (! ((grid_pos[0] + " " + grid_pos[1]) in grid_value))
	{
		return;
	}
	info = '<table border="1"><tr><td>grid</td><td>('+grid_pos[0] + ", " + grid_pos[1]+')</td></tr>'
	+ '<tr><td>location</td><td>('+event.latLng.lat()+', '+event.latLng.lng()+')</td></tr>'
	+ '<tr><td>value</td><td>'+ grid_value[grid_pos[0] + " " + grid_pos[1]] +'</td></tr>'
	+ '<tr><td>color</td><td>'+ grid[grid_pos[0] + " " + grid_pos[1]].fillColor +'</td></tr></table>';
	var infownd = new google.maps.InfoWindow({
		content: info,
		position: event.latLng
	});
	infownd.open(map);
}
function connectRedis(file, cmd)
{
	var xmlhttp;
	if (window.XMLHttpRequest)
	{// code for IE7+, Firefox, Chrome, Opera, Safari
		xmlhttp=new XMLHttpRequest();
	}
	else
	{// code for IE6, IE5
		xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	}
	xmlhttp.onreadystatechange=function()
	{
		if (xmlhttp.readyState==4 && xmlhttp.status==200)
		{
document.getElementById("debug").innerHTML = 'debug: ' + xmlhttp.responseText;
			// save the data into corresponding position in redis_ret
			redis_ret[file] = xmlhttp.responseText;
		}
	}
	xmlhttp.open("GET",file + ".php?" + cmd, true);
	xmlhttp.send();
	// if there is no key in redis_ret, create one
	if (! ((file) in redis_ret))
	{
		redis_ret[file] = "";
	}
}
// generate the trajectory
function robot_move()
{
	connectRedis("get_robot_data", "");
	// separate the data into different robots
	var ret = redis_ret["get_robot_data"].split(", ");
	for (var i = 0; i < ret.length; ++ i)
	{
		// separate the data into different values
		var j = ret[i].split(" ");
		// the 1st is x, and the 2nd is y
		var x = parseFloat(j[1]), y = parseFloat(j[2]);
		if (x == undefined || isNaN(x) || y == undefined || isNaN(y))
			continue;
		last_coord[i] = coord[i];
		//coord[i] = [coord[i][0] + j[1] / 100 * OFFSET - OFFSET / 2, coord[i][1] + j[2] / 100 * OFFSET - OFFSET / 2];
		coord[i] = [j[1], j[2]];
		if (coord[i] == last_coord[i])
		{
			continue;
		}
		// keep the length of path no longer than a threshold
		while (rpath[i].length >= TRAJ_NUM)
		{
			rpath[i][0].setMap(null);
			rpath[i].splice(0, 1);
		}
		var color, weight;
		// select if it is colorful
		if (view_type == "colorful")
		{
			color = "#" + Math.floor(Math.random()*16777215).toString(16);
			weight = 4;
		} else
		{
			color = "black";
			weight = 1;
		}
		if (typeof robot[i] != "undefined")
		{
			robot[i].setMap(null);
		}
		robot[i] = new google.maps.Marker({
			position: new google.maps.LatLng(coord[i][0], coord[i][1]),
			map: map,
			title:"robot"+i,
			icon: "cabs.png"
		});
		rpath[i].push(new google.maps.Polyline({
			map: map,
			path: [new google.maps.LatLng(last_coord[i][0], last_coord[i][1]), new google.maps.LatLng(coord[i][0], coord[i][1])],
			strokeColor: color,
			strokeOpacity: 1,
			strokeWeight: weight
		}));
		if (follow == ""+i)
		{
			// let the map follow a robot
			map.panTo(robot[i].getPosition());
		}
	}
	window.setTimeout(robot_move, TIME_OUT);
}
// generate grids on energy or time distribution
function cal_grid()
{
	if (view_type == "energy" || view_type == "time")
	{
		// simply clear all grids in every iteration
		clear_grid();
		var grid_size = GRID_SIZE * Math.pow(17, 10) / Math.pow(map.getZoom(), 10);
		var center_pos = coord_to_grid(map.getCenter().lat(), map.getCenter().lng());
		var file = "calGrid", cmd = "grid_size=" + grid_size + "&type=" + view_type + "&centerx=" + center_pos[0] + "&centery=" + center_pos[1];
		connectRedis(file, cmd);
		var ret = redis_ret[file].split(" ");
document.getElementById("debug").innerHTML = 'debug: ' + redis_ret[file];
		var dist, min;
		for (var i = 0; i + 3 < ret.length; i += 4)
		{
			// the format of the data is "x y color value"
			var x = ret[i];//Math.round(Math.random() * GRID_NUM - GRID_NUM / 2);
			var y = ret[i+1];
			var color = parseInt(ret[i+2]).toString(16);//Math.round(Math.random() * 160).toString(16);
			if (color.length == 1)
			{
				color = "0" + color;
			}
			else if (color.length > 2)
			{
				color = color.substr(0, 2);
			}
			if (view_type == "energy")
			{
				color = "#FF" + color + color;
			}
			else if (view_type == "time")
			{
				color = "#" + color + color + "FF";
			}
			grid[x + " " + y] = new google.maps.Rectangle({
				strokeColor: 'grey',
				strokeOpacity: 0.2,
				strokeWeight: 1,
				fillColor: color,
				fillOpacity: 0.8,
				map: map,
				title: "value: "+ret[i+3],
				bounds: new google.maps.LatLngBounds(
					new google.maps.LatLng(LAB[0] + x * grid_size, LAB[1] + y * grid_size),
					new google.maps.LatLng(LAB[0] + x * grid_size + grid_size, LAB[1] + y * grid_size + grid_size))
			});
			google.maps.event.clearListeners(grid[x + " " + y], 'click');
			// add the info window into the grid
			google.maps.event.addListener(grid[x + " " + y], 'click', function(event)
			{
				info_wnd(event);
			});
			// save the grid value in order to be displayed on the info window
			grid_value[x + " " + y] = ret[i+3];
		}
	}
	window.setTimeout(cal_grid, TIME_OUT);
}
function initialize()
{
	var mapOptions =
	{
		zoom: 17,
		center: new google.maps.LatLng(LAB[0], LAB[1]),
		mapTypeId: google.maps.MapTypeId.ROADMAP
	};
	map = new google.maps.Map(document.getElementById('map_canvas'),
		mapOptions);
	var marker = new google.maps.Marker({
		position: new google.maps.LatLng(LAB[0], LAB[1]),
		map: map,
		title: 'Autonomy Lab at Simon Fraser University'
	});
	for (var i = 0; i < ROBOT_NUM; ++ i)
	{
		coord.push([LAB[0], LAB[1]]);
		rpath.push(new Array());
	}
	robot_move();
	cal_grid();
	google.maps.event.addListener(map, 'zoom_changed', function()
	{
		clear_grid();
	});
}
google.maps.event.addDomListener(window, 'load', initialize);
		</script>
	</head>
	<body>
		<table border="0" width="100%" align="center">
			<tr>
				<td width="30"><img src="logo.png" alt="logo"></td>
				<td><h1 align='center'>Gmap for Autolab Demonstration</h1></td>
			</tr>
		</table>
		<div id="map_canvas"></div>
		<table border="0" align="center" width="40%" >
			<tr>
				<td>
					<form align="center">
						<select name="view" onClick="change_view(this.form)">
							<option value="basic" selected="selected">basic</option>
							<option value="energy">energy map</option>
							<option value="time">time map</option>
							<option value="colorful">colorful trajectory</option>
						</select>
					</form>
				</td>
				<td>follow:
					<form align="center">
						<select name="follow" onClick="follow_robot(this.form)">
							<option value="none" selected="selected">none</option>
							<option value="0">0</option>
							<option value="1">1</option>
							<option value="2">2</option>
						</select>
					</form>
				</td>
			</tr>
		</table>
		<p id="debug">debug: </p>
		<p id="debug2">debug2: </p>
	</body>
</html>